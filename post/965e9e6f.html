<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>深入理解JVM 中 | Error0 Blog·错误零</title><meta name="author" content="麦兜"><meta name="copyright" content="麦兜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言经过上一篇文章《深入理解JVM 上》的内容总结可以让自己知道JVM大致的运行原理，本章接下来介绍的是如何解析与加载类。 Class文件存储的是字节码是为了跨平台运行而设计，这种结构不仅仅是能存储Java语言，比如Kotlin也可以编译为Class文件虚拟机一样可以运行，虚拟机无需关心Class的来源是什么语言因为它更像一个独立的系统。 Class文件结构Class文件是一组以8个字节为基础单">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解JVM 中">
<meta property="og:url" content="http://www.error0.cn/post/965e9e6f.html">
<meta property="og:site_name" content="Error0 Blog·错误零">
<meta property="og:description" content="前言经过上一篇文章《深入理解JVM 上》的内容总结可以让自己知道JVM大致的运行原理，本章接下来介绍的是如何解析与加载类。 Class文件存储的是字节码是为了跨平台运行而设计，这种结构不仅仅是能存储Java语言，比如Kotlin也可以编译为Class文件虚拟机一样可以运行，虚拟机无需关心Class的来源是什么语言因为它更像一个独立的系统。 Class文件结构Class文件是一组以8个字节为基础单">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.error0.cn/uploads/3166817309.png">
<meta property="article:published_time" content="2020-07-26T02:50:00.000Z">
<meta property="article:modified_time" content="2021-04-03T12:11:16.128Z">
<meta property="article:author" content="麦兜">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.error0.cn/uploads/3166817309.png"><link rel="shortcut icon" href="//img.error0.cn/v2-a168b974dd58ec853a99784ab19dbd84_720w.jpg"><link rel="canonical" href="http://www.error0.cn/post/965e9e6f"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-03 20:11:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="//img.error0.cn/v2-a168b974dd58ec853a99784ab19dbd84_720w.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Artitalk/"><i class="fa-fw fas fa-comment"></i><span> 碎言</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('//img.error0.cn/uploads/3166817309.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Error0 Blog·错误零</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Artitalk/"><i class="fa-fw fas fa-comment"></i><span> 碎言</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">深入理解JVM 中</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-26T02:50:00.000Z" title="发表于 2020-07-26 10:50:00">2020-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-03T12:11:16.128Z" title="更新于 2021-04-03 20:11:16">2021-04-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="深入理解JVM 中"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="//img.error0.cn/uploads/3166817309.png" alt="封面图.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过上一篇文章《深入理解JVM 上》的内容总结可以让自己知道JVM大致的运行原理，本章接下来介绍的是如何解析与加载类。</p>
<p>Class文件存储的是字节码是为了跨平台运行而设计，这种结构不仅仅是能存储Java语言，比如Kotlin也可以编译为Class文件虚拟机一样可以运行，虚拟机无需关心Class的来源是什么语言因为它更像一个独立的系统。</p>
<h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><p>Class文件是一组以8个字节为基础单位的二进制流， 各个数据项目严格按照顺序紧凑地排列在文件之中， 中间没有添加任何分隔符， 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据， <strong>没有空隙</strong>存在。 当遇到需要占用8个字节以上空间的数据项时， 则会按照高位在前(高位字节在地址最低位，最低字节在地址最高位来存储数据  )的方式分割成若干个8个字节进行存储。  下方是代码对应编译好的Class文件的HEX，例如：HelloWorld.Class “<strong>0xCAFEBABE</strong>”四个字节的“<strong>魔数</strong>” （00~03），接着（04-07）<strong>Class主副版本号</strong>，这组8个字节是为了保证虚拟机识别文件而设计。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此源码使用的是java1.8编译</span></span><br><span class="line"><span class="keyword">package</span> cn.error0;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//Print Hello World</span></span><br><span class="line">     System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="//img.error0.cn/uploads/2392375910.png" alt="HelloWorldClassHEX.png"></p>
<h2 id="Class文件存储结构"><a href="#Class文件存储结构" class="headerlink" title="Class文件存储结构"></a>Class文件存储结构</h2><p>根据《Java虚拟机规范》 的规定， Class文件格式采用一种类似于C语言结构体的伪结构来存储数<br>据， 这种伪结构中只有两种数据类型： “无符号数”和“表”。 后面的解析都要以这两种数据类型为基<br>础， 所以需要理解这两个概念。</p>
<p><strong>无符号数</strong>属于基本的数据类型， 以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个字节和8个<br>字节的无符号数， 无符号数可以用来描述数字、 索引引用、 数量值或者按照UTF-8编码构成字符串<br>值。<br><strong>表</strong>是由<strong>多个无符号数</strong>或者<strong>其他表</strong>作为数据项构成的复合数据类型， 为了便于区分， 所有<strong>表的命名</strong><br>都习惯性地以“<strong>_info</strong>”结尾。 表用于描述有层次关系的复合结构的数据， 整个Class文件本质上也可以视<br>作是一张表。表是由任意数量的可变长度的项组成，用于表示class文件内容的一系列复合结构。本章出现的ASCII字符都为Unicode码点。</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>类型（字段 or 表）</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
</tr>
<tr>
<td>u2</td>
<td>constant_ pool_ count</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_ pool [constant_ pool_ count- 1]</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces [interfaces_count]</td>
</tr>
<tr>
<td>u2</td>
<td>fields_ count</td>
</tr>
<tr>
<td>field_info</td>
<td>fields[fields_ count]</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
</tr>
<tr>
<td>method_info</td>
<td>methods[methods_ count]</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes[attributes_count]</td>
</tr>
</tbody></table>
<h3 id="Magic-魔数"><a href="#Magic-魔数" class="headerlink" title="Magic 魔数"></a>Magic 魔数</h3><p>Magin的作用是确定这个文件能不能被虚拟机接受，魔数数字固定为<strong>0xCAFEBABE</strong>不会改变。</p>
<h3 id="minor-version-副版本号-major-version（主版本号）"><a href="#minor-version-副版本号-major-version（主版本号）" class="headerlink" title="minor_version (副版本号) major_version（主版本号）"></a>minor_version (副版本号) major_version（主版本号）</h3><p>如果某个class文件的主版本号为M,副版本号为m那个么这个class文件的格式版本号为M.m。</p>
<p>版本号可以按字母顺序排序，比如1.5&lt;2.0&lt;2.1。假设一个class文件版本号为V，那么Mi.0&lt;=V&lt;=MJ.m时才会被次虚拟机支持。</p>
<h3 id="constant-pool-count-常量池计数器"><a href="#constant-pool-count-常量池计数器" class="headerlink" title="constant_ pool_ count  常量池计数器"></a>constant_ pool_ count  常量池计数器</h3><p>constant_ pool_ count 的值等于常量池表中的成员数加1，对于long和double类型有例外情况，因为long和double是占用8个字节所以需要常量池池的成员加2。常量池表的索引值<br>只有在大于0且小于constant_ pool_ count 时才会认为是有效的。</p>
<h3 id="constant-pool-常量池"><a href="#constant-pool-常量池" class="headerlink" title="constant_ pool[] 常量池"></a>constant_ pool[] 常量池</h3><blockquote>
<p>常量池tag值不连续是因为解决兼容等问题 具体参考 <a target="_blank" rel="noopener" href="https://hllvm-group.iteye.com/group/topic/38367">传送门</a></p>
</blockquote>
<p>constant_ pool[]是一种表结构，它包含class文件结构及其子结构中引用的所以字符串常量、类或接口名、字段名、其他常量。引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征一一 <strong>第1个字节</strong>作为类型标记，<strong>用于确定该项的格式</strong>，这个字节称为<strong>tag byte</strong> (标记字节、标签字节)。</p>
<p>常量池以1 ~ constant_ pool_ count-1 为索引，常量池各个表也有着完全独立的数据结构，他们之前并没有共性和联系。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>tag</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_ UTF-8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_ Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_ Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_ Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_ Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_ Class_info</td>
<td>7</td>
<td>类或接口的引用</td>
</tr>
<tr>
<td>CONSTANT_ String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_ Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_ Methodref_info</td>
<td>10</td>
<td>类中的方法引用</td>
</tr>
<tr>
<td>CONSTANT_ InterfaceMethodref_info</td>
<td>11</td>
<td>接口中的方法引用</td>
</tr>
<tr>
<td>CONSTANT_ NameAndType_info</td>
<td>12</td>
<td>字段或方法的部分符号引用</td>
</tr>
<tr>
<td>CONSTANT_ MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_ MethodType_info</td>
<td>16</td>
<td>表示方法类型</td>
</tr>
</tbody></table>
<h3 id="CONSTANT-Utf8-info"><a href="#CONSTANT-Utf8-info" class="headerlink" title="CONSTANT_ Utf8_info"></a>CONSTANT_ Utf8_info</h3><blockquote>
<p>UTF-8缩略编码与普通UTF-8编码的区别是：<br>从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码） 的缩略编码使用一个字节表示，<br>从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示， 从’\u0800’开始到’\uffff’之间的所有字符<br>的缩略编码就按照普通UTF-8编码规则使用三个字节表示。  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*需要注意的是CONSTANT_Utf8_info用于描述字段、方法等的名称，所以CONSTANT_Utf8_info长度是它们最大的长度 u2最大值为65535，所以超出64kb的变量名或方法名是无法编译的*/</span></span><br><span class="line">CONSTANT_Utf8_info</span><br><span class="line">&#123;</span><br><span class="line">		u1 tag;  <span class="comment">//&#123;tag:1&#125;</span></span><br><span class="line">		u2 lenth; <span class="comment">//length值说明了这个UTF-8编码的字符串长度是多少字节</span></span><br><span class="line">		u1 bytes[length];<span class="comment">//长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTANT-Integer-info"><a href="#CONSTANT-Integer-info" class="headerlink" title="CONSTANT_ Integer_info"></a>CONSTANT_ Integer_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Integer_info</span><br><span class="line">&#123;</span><br><span class="line">		u1 tag;  <span class="comment">//&#123;tag:3&#125;</span></span><br><span class="line">		u4 bytes;<span class="comment">//按照高位在前存储的int值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTANT-Float-info"><a href="#CONSTANT-Float-info" class="headerlink" title="CONSTANT_ Float_info"></a>CONSTANT_ Float_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Float_info</span><br><span class="line">&#123;</span><br><span class="line">		u1 tag;  <span class="comment">//&#123;tag:4&#125;</span></span><br><span class="line">		u4 bytes;<span class="comment">//按照高位在前存储的Float值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTANT-Long-info"><a href="#CONSTANT-Long-info" class="headerlink" title="CONSTANT_ Long_info"></a>CONSTANT_ Long_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Long_info</span><br><span class="line">&#123;</span><br><span class="line">		u1 tag;  <span class="comment">//&#123;tag:5&#125;</span></span><br><span class="line">		u8 bytes;<span class="comment">//按照高位在前存储的Long值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTANT-Double-info"><a href="#CONSTANT-Double-info" class="headerlink" title="CONSTANT_ Double_info"></a>CONSTANT_ Double_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Double_info</span><br><span class="line">&#123;</span><br><span class="line">		u1 tag;  <span class="comment">//&#123;tag:6&#125;</span></span><br><span class="line">		u8 bytes;<span class="comment">//按照高位在前存储的Double值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTANT-Class-info"><a href="#CONSTANT-Class-info" class="headerlink" title="CONSTANT_ Class_info"></a>CONSTANT_ Class_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_ Class_info</span><br><span class="line">&#123;</span><br><span class="line">		u1 tag;  <span class="comment">//&#123;tag:7&#125;</span></span><br><span class="line">		u2 name_index;<span class="comment">//常量池的索引值，它指向常量池中一个CONSTANT_ Utf8_info类型的常量 代表了这个类或接口的全限定名。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTANT-String-info"><a href="#CONSTANT-String-info" class="headerlink" title="CONSTANT_ String_info"></a>CONSTANT_ String_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_ String_info</span><br><span class="line">&#123;</span><br><span class="line">		u1 tag;  <span class="comment">//&#123;tag:8&#125;</span></span><br><span class="line">		u2 index;<span class="comment">//指向字符串字而量的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTANT-Fieldref-info"><a href="#CONSTANT-Fieldref-info" class="headerlink" title="CONSTANT_ Fieldref_info"></a>CONSTANT_ Fieldref_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_ Fieldref_info</span><br><span class="line">&#123;</span><br><span class="line">		u1 tag;  <span class="comment">//&#123;tag:9&#125;</span></span><br><span class="line">		u2 index;<span class="comment">//指向声明字段的类或者接口描述符CONSTANT_ Class_info的索引项</span></span><br><span class="line">		u2 index;<span class="comment">//指向字段描述符CONSTANT_NameAndType的索引项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="CONSTANT-Methodref-info"><a href="#CONSTANT-Methodref-info" class="headerlink" title="CONSTANT_ Methodref_info"></a>CONSTANT_ Methodref_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_ Methodref_info</span><br><span class="line">&#123;</span><br><span class="line">	    u1 tag;  <span class="comment">//&#123;tag:10&#125;</span></span><br><span class="line">	    u2 index;<span class="comment">//指向声明方法的类描述符CONSTANT_Class_info的索引项</span></span><br><span class="line">	    u2 index;<span class="comment">//指向字段描述符CONSTANT_NameAndType的索引项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTANT-InterfaceMethodref-info"><a href="#CONSTANT-InterfaceMethodref-info" class="headerlink" title="CONSTANT_ InterfaceMethodref_info"></a>CONSTANT_ InterfaceMethodref_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_ InterfaceMethodref_info</span><br><span class="line">&#123;</span><br><span class="line">	    u1 tag;  <span class="comment">//&#123;tag:11&#125;</span></span><br><span class="line">	    u2 index;<span class="comment">//指向声明方法的类描述符CONSTANT_Class_info的索引项</span></span><br><span class="line">	    u2 index;<span class="comment">//指向字段描述符CONSTANT_NameAndType的索引项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTAT-NameAndType-info"><a href="#CONSTAT-NameAndType-info" class="headerlink" title="CONSTAT_ NameAndType_info"></a>CONSTAT_ NameAndType_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_ NameAndType_info</span><br><span class="line">&#123;</span><br><span class="line">	    u1 tag;  <span class="comment">//&#123;tag:12&#125;</span></span><br><span class="line">	    u2 index;<span class="comment">//指向该字段或方法名称常量项的索引</span></span><br><span class="line">	    u2 index;<span class="comment">//指向该字段或方法描述符常量项的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTANT-MethodHandle-info"><a href="#CONSTANT-MethodHandle-info" class="headerlink" title="CONSTANT_ MethodHandle_info"></a>CONSTANT_ MethodHandle_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_ MethodHandle_info</span><br><span class="line">&#123;</span><br><span class="line">	    u1 tag;  <span class="comment">//&#123;tag:15&#125;</span></span><br><span class="line">	    u1 reference_ kind <span class="comment">//值必须在1至9之间(包括1和9).它决定了方法句柄的类型。方法句柄类型的值表示方法句柄的字节码行为</span></span><br><span class="line">	    u2 refercnce_index;<span class="comment">//值必须是对常量池的有效索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSTANT-MethodType-info"><a href="#CONSTANT-MethodType-info" class="headerlink" title="CONSTANT_ MethodType_info"></a>CONSTANT_ MethodType_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_ MethodType_info</span><br><span class="line">&#123;</span><br><span class="line">	    u1 tag;  <span class="comment">//&#123;tag:16&#125;</span></span><br><span class="line">	    u2 descriptor_index;<span class="comment">//值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Uif8_ info结构，表示方法的描述符</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="access-flags-访问标志"><a href="#access-flags-访问标志" class="headerlink" title="access_flags 访问标志"></a>access_flags 访问标志</h3><table>
<thead>
<tr>
<th>标志名</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0X0001</td>
<td>声明为public,可以从包外访问</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0X0010</td>
<td>声明为final，不允许有子类</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0X0020</td>
<td>当用到invokespecial指令时，需要对父类方法做特殊处理</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0X0200</td>
<td>该class文件定义的是接口而不是类</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0X0400</td>
<td>声明为abstract,不能被实例化</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0X1000</td>
<td>声明为synthetic,表示该class文件并非由Java源代码所生成</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0X2000</td>
<td>标识注解类型</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0X4000</td>
<td>标识枚举类型</td>
</tr>
</tbody></table>
<h3 id="this-class-类索引"><a href="#this-class-类索引" class="headerlink" title="this_class 类索引"></a>this_class 类索引</h3><p>this_ class 的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为<strong>CONSTANT_Class_ info</strong> 类型结构体，该结构体表示这个class文件所定义的类或接口。</p>
<h3 id="super-class-父类索引"><a href="#super-class-父类索引" class="headerlink" title="super_class  父类索引"></a>super_class  父类索引</h3><p>对于类来说，super_ class 的值要么是0,要么是对常量池表中某项的一个有效索引值。如果它的值不为0,那么常池在这个索引处的成员必须为CONSTANT_Class_ info 类型常量。如果没有父类默认为0，表示Object类，因为唯一这个类没有父类。</p>
<h3 id="interfaces-count-接口计算器"><a href="#interfaces-count-接口计算器" class="headerlink" title="interfaces_count 接口计算器"></a>interfaces_count 接口计算器</h3><p>表示当前类或接口的直接超接口数量。</p>
<h3 id="interfaces-接口表"><a href="#interfaces-接口表" class="headerlink" title="interfaces[] 接口表"></a>interfaces[] 接口表</h3><p>interfaces []中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为interfaces_ count。 每个成员interfaces[i]必须为CONSTANT_ Class_info结构其中0≤interfaces_count 。在interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序(从左至右)一样，即interfaces [0]对应的是源代码中最左边的接口。</p>
<p>类索引、父类索引和接口表确定了该类的继承关系，类索引确定了这个类的全限定名，父类索引确定了这个类的父类全限定名。</p>
<h3 id="类索引查找全限定名过程"><a href="#类索引查找全限定名过程" class="headerlink" title="类索引查找全限定名过程"></a>类索引查找全限定名过程</h3><p>通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串  </p>
<p><img src="//img.error0.cn/uploads/3806985827.png" alt="类索引查找全限定名过程.png"></p>
<h3 id="fields-count-字段计数器"><a href="#fields-count-字段计数器" class="headerlink" title="fields_count 字段计数器"></a>fields_count 字段计数器</h3><p>用于表示该类或接口的类字段或者实例字段的数量。</p>
<h3 id="fields-字段表"><a href="#fields-字段表" class="headerlink" title="fields[] 字段表"></a>fields[] 字段表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">field_info</span><br><span class="line">&#123;</span><br><span class="line">		u2 access_flags; <span class="comment">//字段的访问权限标志</span></span><br><span class="line">		u2 name_index; <span class="comment">//值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Uif8_ info结构，表示方法的描述符</span></span><br><span class="line">		u2 descriptor_index;<span class="comment">//值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Uif8_ info结构，表示方法的描述符</span></span><br><span class="line">		u2 attributes_cout;<span class="comment">//表示当前字段的附加属性的数量</span></span><br><span class="line">  	attribute_info attributes[attributes_cout];<span class="comment">//属性表，其值必须是attribute_info</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字段表的属性和访问各个标志"><a href="#字段表的属性和访问各个标志" class="headerlink" title="字段表的属性和访问各个标志"></a>字段表的属性和访问各个标志</h4><table>
<thead>
<tr>
<th>标志名称</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>声明为public，可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>声明为private，只能在定义该字段的类中访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>声明为protected,子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>声明为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>声明为final,对象构造好之后，就不能直接设置该字段了</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>声明为volatile,被标识的字段无法缓存</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x0080</td>
<td>声明为transient,被标识的字段不会为持久化对象管理器所写人或读取</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>被表示的字段由编译器产生，而没有写源代码中</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4001</td>
<td>该字段声明为某个枚举类型(enum)的成员</td>
</tr>
</tbody></table>
<p>class文件中的字段可以设置多个标志。不过有些标志是互斥的一个字段最多只能设置ACC_ <em>PRIVATE, ACC</em> <em>PROTECTED 和ACC_PUBLIC 个标志中的一个，也不能同时设置标志ACC_ <em>FINAL 和ACC</em> VO<br>接口中的所有字段都具有ACC</em> PUBLIC、 ACC_ STATIC 和ACC_ FINAL标志，也可以设置ACC_ SYNTHETIC标志，但是不能含有其他标志如果字段带有ACC_ SYNTHETIC 标志，则说明这个字段不是由源码产生的，而是由编译器自动产生的。如果字段带有ACC_ ENUM 标志，这说明这个字段是一个枚举类型的成员。</p>
<h3 id="methods-count-方法计数器"><a href="#methods-count-方法计数器" class="headerlink" title="methods_count 方法计数器"></a>methods_count 方法计数器</h3><p>methods_count的值表示当前class文件methods表的成员个数。methods<br>表中每个成员都是一个 method_ info结构。</p>
<h3 id="methods-方法表"><a href="#methods-方法表" class="headerlink" title="methods[] 方法表"></a>methods[] 方法表</h3><p>methods表中的每个成员都必须是一个method_ info 结构,用于表示当前类或接口中某个方法的完整描述。<br>method_ info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法。methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods_info</span><br><span class="line">&#123;</span><br><span class="line">		u2 access_flags; <span class="comment">//方法的访问权限标志</span></span><br><span class="line">		u2 name_index; <span class="comment">//值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Uif8_ info结构，表示方法的描述符</span></span><br><span class="line">		u2 descriptor_index;<span class="comment">//值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Uif8_ info结构，表示方法的描述符</span></span><br><span class="line">		u2 attributes_cout;<span class="comment">//表示当前方法的附加属性的数量</span></span><br><span class="line">		attribute_info attributes[attributes_cout];<span class="comment">//属性表，其值必须是attribute_info</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="attributes-count-属性计数器"><a href="#attributes-count-属性计数器" class="headerlink" title="attributes_count 属性计数器"></a>attributes_count 属性计数器</h3><p>attributes_ count 的值表示当前class文件属性表的成员个数。属性表中每一<br>项都是一个attribute_ info结构 </p>
<h3 id="attributes-info-属性表"><a href="#attributes-info-属性表" class="headerlink" title="attributes_info 属性表"></a>attributes_info 属性表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods_info</span><br><span class="line">&#123;</span><br><span class="line">		u2 attribute_name_index; <span class="comment">//对于任意属性，attribute_name_index必须是对当前class文件的常量池的有效16位无符号索引。常量池在该索引处的成员必须是CONSTANT_ Utf8_ info </span></span><br><span class="line">		u4 attribute_length; </span><br><span class="line">		u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote>
<p>本文章只给出了Class结构的部分属性，如需要请参考《Java虚拟机规范》。</p>
</blockquote>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OS:Mac OS</span><br><span class="line">编译器：VS Code、IDEA </span><br><span class="line">插件：VS Code-hexdump</span><br><span class="line">Java:1.7</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此源码使用的是JDK7编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Print Hello World</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="//img.error0.cn/uploads/4205829315.png" alt="HelloWorld.png"></p>
<p>IDEA编译完成后class文件存放在/demo/out/</p>
<h4 id="Hex"><a href="#Hex" class="headerlink" title="Hex"></a>Hex</h4><p>使用VSCode安装hexdump插件，然后打开Class文件。</p>
<p><img src="//img.error0.cn/uploads/2980628383.png" alt="VSCodeHex.png"></p>
<h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><p>用VSCode打开Class文件后可以看到前4个字节的十六进制表示的为<code>0xCAFFBABE</code>用于作为JVM可鉴别的文件，接下来四个字节为<code>00 00 00 33</code>  主版本号为33 十进制为51对应的版本号也就是JDK7。</p>
<p><img src="//img.error0.cn/uploads/3748197166.png" alt="Hex07.png"></p>
<p><img src="//img.error0.cn/uploads/2390478984.png" alt="JDk版本号.png"></p>
<p>紧接着为常量池的入口，两个字节（u2）<code>00 22</code>表示为常量池计数器（constant_ pool_ count ）的数值 0x0022十进制为34代表这个Class文件的常量池有34项常量值,这个容器计数是从1而不是0开始索引取值为1～33。设计者将第0项常量用于表达不需要引用一个常量池项目含义。除了常量池索引为1开始其他集合都从0开始。</p>
<p><img src="//img.error0.cn/uploads/1232832428.png" alt="Hex0809.png"></p>
<p><strong>第一个</strong>常量为（偏移地址0x0000000A～0x0000000E）<code>0A 00 06 00 14</code>，（偏移地址0x0000000A）<code>0x0A</code>十进制为10（tag）对应常量池表为 CONSTANT_ Methodref_info 方法引用 ，接下来（偏移地址0x0000000C）<code>0x0006</code>十进制为6 指向的是第6个常量索引，第6个常量必须为CONSTANT_ Class_info也就是那个类引用这个方法的意思。（偏移地址0x0000000E）两个字节为<code>0x0014</code>十进制20，指向类型为CONSTANT_ NameAndType_info用于描述方法的方法名与返回值类型。可以推断这是一个类方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_ Methodref_info</span><br><span class="line">&#123;</span><br><span class="line">	    u1 tag;  <span class="comment">//&#123;tag:10&#125;</span></span><br><span class="line">	    u2 index;<span class="comment">//&#123;index:第6项常量&#125;   #27  java/lang/Object</span></span><br><span class="line">    	u2 index;<span class="comment">//&#123;index:第20项常量&#125; &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二个</strong>常量（偏移地址0x0000000F～0x00000103）（偏移地址0x0000000F）<code>0x09</code>十进制为9（tag）对应的常量表为CONSTANT_Fieldref_info,（偏移地址0x00000101）<code>0x0015</code>十进制为21 ，（偏移地址0x00000103）0x0016十进制为22</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Fieldref_info</span><br><span class="line">&#123;</span><br><span class="line">		u1 tag;  <span class="comment">//&#123;tag:9&#125;</span></span><br><span class="line">		u2 index;<span class="comment">//&#123;index:第21项常量&#125;</span></span><br><span class="line">		u2 index;<span class="comment">//&#123;index:第22项常量&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>因常量数量太多就不接着手动反编译了（主要怕文章太长了），java官方内置反编译工具 javap可以用来参考或者验证自己手动反编译结果。常量池结束后为代码块存储在常量池的属性表集合用于存储方法执行指令、局部变量等。</p>
<p>使用方式：<code>javap -verbose xxx.class</code></p>
<p>#1代表为第一个常量，#1 = Methodref 表示这个常量为类中的方法引用，接着为常量的构造值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;HelloWorld.java&quot;</span></span><br><span class="line">public class HelloWorld</span><br><span class="line">SourceFile: <span class="string">&quot;HelloWorld.java&quot;</span></span><br><span class="line">	minor version: 0</span><br><span class="line">	major version: 51</span><br><span class="line">	flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">	<span class="comment">#1 = Methodref     #6.#20     // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">	<span class="comment">#2 = Fieldref      #21.#22    // java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">	<span class="comment">#3 = String       #23      // Hello World</span></span><br><span class="line">	<span class="comment">#4 = Methodref     #24.#25    // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">	<span class="comment">#5 = Class       #26      // HelloWorld</span></span><br><span class="line">	<span class="comment">#6 = Class       #27      // java/lang/Object</span></span><br><span class="line">	<span class="comment">#7 = Utf8        &lt;init&gt;</span></span><br><span class="line">	<span class="comment">#8 = Utf8        ()V</span></span><br><span class="line">	<span class="comment">#9 = Utf8        Code</span></span><br><span class="line">	<span class="comment">#10 = Utf8        LineNumberTable</span></span><br><span class="line">	<span class="comment">#11 = Utf8        LocalVariableTable</span></span><br><span class="line">	<span class="comment">#12 = Utf8        this</span></span><br><span class="line">	<span class="comment">#13 = Utf8        LHelloWorld;</span></span><br><span class="line">	<span class="comment">#14 = Utf8        main</span></span><br><span class="line">	<span class="comment">#15 = Utf8        ([Ljava/lang/String;)V</span></span><br><span class="line">	<span class="comment">#16 = Utf8        args</span></span><br><span class="line">	<span class="comment">#17 = Utf8        [Ljava/lang/String;</span></span><br><span class="line">	<span class="comment">#18 = Utf8        SourceFile</span></span><br><span class="line">	<span class="comment">#19 = Utf8        HelloWorld.java</span></span><br><span class="line">	<span class="comment">#20 = NameAndType    #7:#8     // &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">	<span class="comment">#21 = Class       #28      // java/lang/System</span></span><br><span class="line">	<span class="comment">#22 = NameAndType    #29:#30    // out:Ljava/io/PrintStream;</span></span><br><span class="line">	<span class="comment">#23 = Utf8        Hello World</span></span><br><span class="line">	<span class="comment">#24 = Class       #31      // java/io/PrintStream</span></span><br><span class="line">	<span class="comment">#25 = NameAndType    #32:#33    // println:(Ljava/lang/String;)V</span></span><br><span class="line">	<span class="comment">#26 = Utf8        HelloWorld</span></span><br><span class="line">	<span class="comment">#27 = Utf8        java/lang/Object</span></span><br><span class="line">	<span class="comment">#28 = Utf8        java/lang/System</span></span><br><span class="line">	<span class="comment">#29 = Utf8        out</span></span><br><span class="line">	<span class="comment">#30 = Utf8        Ljava/io/PrintStream;</span></span><br><span class="line">	<span class="comment">#31 = Utf8        java/io/PrintStream</span></span><br><span class="line">	<span class="comment">#32 = Utf8        println</span></span><br><span class="line">	<span class="comment">#33 = Utf8        (Ljava/lang/String;)V</span></span><br><span class="line">&#123;</span><br><span class="line">public HelloWorld();</span><br><span class="line">flags: ACC_PUBLIC  </span><br><span class="line">Code:</span><br><span class="line">stack=1, locals=1, args_size=1 </span><br><span class="line">0: aload_0    </span><br><span class="line">1: invokespecial <span class="comment">#1         // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">4: <span class="built_in">return</span>     </span><br><span class="line">LineNumberTable:</span><br><span class="line">ine 2: 0</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name  Signature 0    5   0 this  LHelloWorld;</span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">   stack=2, locals=1, args_size=1</span><br><span class="line">   0: getstatic   <span class="comment">#2         // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   3: ldc      <span class="comment">#3         // String Hello World</span></span><br><span class="line">   5: invokevirtual <span class="comment">#4         // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   8: <span class="built_in">return</span>     </span><br><span class="line">   LineNumberTable:</span><br><span class="line">   line 5: 0</span><br><span class="line">	 line 6: 8</span><br><span class="line">   LocalVariableTable:</span><br><span class="line">   Start Length Slot Name  Signature</span><br><span class="line">   0    9   0 args  [Ljava/lang/String;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JVM加载类"><a href="#JVM加载类" class="headerlink" title="JVM加载类"></a>JVM加载类</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载<br>(Loading)、验证(Verification) 、准备(Preparation) 、解析(Resolution) 、初始化<br>(Initialization)、使用(Using) 和卸载(Unloading) 七个阶段，其中验证、准备、解析三个部分统称<br>为连接(Linking) 。</p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按 照这种顺序按部就班地开始，而解析阶段则不一定:它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性(也称为动态绑定或晚期绑定)。请注意，这里笔者写的是 按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，强调这点是因为这些阶段通常都 是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p>
<p><img src="//img.error0.cn/uploads/4101448148.png" alt="类的生命周期.png"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对 象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既 可以从 ZIP 包中读取(比如从 jar 包和 war 包中读取)，也可以在运行时计算生成(动态代理)， 也可以由其它文件生成(比如将 JSP 文件转换成对应的 Class 类)。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使 用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为: <code>public static int v = 8080;</code></p>
<p>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是 程序被编译后，存放于类构造器<client>方法之中。</p>
<p> 但是注意如果声明为:<code>public static final int v = 8080;</code>在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的:</p>
<ol>
<li>CONSTANT_Class_info</li>
<li>CONSTANT_Field_info</li>
<li>CONSTANT_Method_info  等类常量</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提供了 3 种类加载器:</p>
<p><strong>启动类加载器</strong>(Bootstrap ClassLoader)负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被 虚拟机认可(按文件名识别，如 rt.jar)的类。</p>
<p><strong>扩展类加载器**</strong>(Extension ClassLoader)**</p>
<p><strong>应用程序类加载器</strong>(Application ClassLoader)负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。</p>
<p><strong>应用程序类加载器</strong>(Application ClassLoader)负责加载用户路径(classpath)上的类库。JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。</p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p> 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需加载的Class)，子类加载器才会尝试自己去加载。采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">麦兜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.error0.cn/post/965e9e6f.html">http://www.error0.cn/post/965e9e6f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.error0.cn" target="_blank">Error0 Blog·错误零</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="//img.error0.cn/uploads/3166817309.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/dcfbbde9.html"><img class="prev-cover" src="//img.error0.cn/uploads/2944888906.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">手写框架带你理解SpringMVC过程原理</div></div></a></div><div class="next-post pull-right"><a href="/post/d83a7781.html"><img class="next-cover" src="//img.error0.cn/uploads/1650618595.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">自己动手编译一个Java</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="//img.error0.cn/v2-a168b974dd58ec853a99784ab19dbd84_720w.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">麦兜</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" href="javascript:void(0)"><i class="fa fa-star"></i><span>收藏本站</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/error0g" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.yuque.com/buhuifeidechaoren/uf9qxf" target="_blank" title="笔记"><i class="fa fa-file"></i></a><a class="social-icon" href="mailto:error0@yeah.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">暂无公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">Class文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">Class文件存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Magic-%E9%AD%94%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">Magic 魔数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#minor-version-%E5%89%AF%E7%89%88%E6%9C%AC%E5%8F%B7-major-version%EF%BC%88%E4%B8%BB%E7%89%88%E6%9C%AC%E5%8F%B7%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">minor_version (副版本号) major_version（主版本号）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constant-pool-count-%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">constant_ pool_ count  常量池计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constant-pool-%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">2.1.4.</span> <span class="toc-text">constant_ pool[] 常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-Utf8-info"><span class="toc-number">2.1.5.</span> <span class="toc-text">CONSTANT_ Utf8_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-Integer-info"><span class="toc-number">2.1.6.</span> <span class="toc-text">CONSTANT_ Integer_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-Float-info"><span class="toc-number">2.1.7.</span> <span class="toc-text">CONSTANT_ Float_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-Long-info"><span class="toc-number">2.1.8.</span> <span class="toc-text">CONSTANT_ Long_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-Double-info"><span class="toc-number">2.1.9.</span> <span class="toc-text">CONSTANT_ Double_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-Class-info"><span class="toc-number">2.1.10.</span> <span class="toc-text">CONSTANT_ Class_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-String-info"><span class="toc-number">2.1.11.</span> <span class="toc-text">CONSTANT_ String_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-Fieldref-info"><span class="toc-number">2.1.12.</span> <span class="toc-text">CONSTANT_ Fieldref_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-Methodref-info"><span class="toc-number">2.1.13.</span> <span class="toc-text">CONSTANT_ Methodref_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-InterfaceMethodref-info"><span class="toc-number">2.1.14.</span> <span class="toc-text">CONSTANT_ InterfaceMethodref_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTAT-NameAndType-info"><span class="toc-number">2.1.15.</span> <span class="toc-text">CONSTAT_ NameAndType_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-MethodHandle-info"><span class="toc-number">2.1.16.</span> <span class="toc-text">CONSTANT_ MethodHandle_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONSTANT-MethodType-info"><span class="toc-number">2.1.17.</span> <span class="toc-text">CONSTANT_ MethodType_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#access-flags-%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97"><span class="toc-number">2.1.18.</span> <span class="toc-text">access_flags 访问标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-class-%E7%B1%BB%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.19.</span> <span class="toc-text">this_class 类索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-class-%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.20.</span> <span class="toc-text">super_class  父类索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interfaces-count-%E6%8E%A5%E5%8F%A3%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">2.1.21.</span> <span class="toc-text">interfaces_count 接口计算器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interfaces-%E6%8E%A5%E5%8F%A3%E8%A1%A8"><span class="toc-number">2.1.22.</span> <span class="toc-text">interfaces[] 接口表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E5%85%A8%E9%99%90%E5%AE%9A%E5%90%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.23.</span> <span class="toc-text">类索引查找全限定名过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fields-count-%E5%AD%97%E6%AE%B5%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.24.</span> <span class="toc-text">fields_count 字段计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fields-%E5%AD%97%E6%AE%B5%E8%A1%A8"><span class="toc-number">2.1.25.</span> <span class="toc-text">fields[] 字段表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E8%AE%BF%E9%97%AE%E5%90%84%E4%B8%AA%E6%A0%87%E5%BF%97"><span class="toc-number">2.1.25.1.</span> <span class="toc-text">字段表的属性和访问各个标志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#methods-count-%E6%96%B9%E6%B3%95%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.26.</span> <span class="toc-text">methods_count 方法计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#methods-%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">2.1.27.</span> <span class="toc-text">methods[] 方法表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#attributes-count-%E5%B1%9E%E6%80%A7%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.28.</span> <span class="toc-text">attributes_count 属性计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#attributes-info-%E5%B1%9E%E6%80%A7%E8%A1%A8"><span class="toc-number">2.1.29.</span> <span class="toc-text">attributes_info 属性表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.2.</span> <span class="toc-text">实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hex"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">Hex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="toc-number">2.2.0.4.</span> <span class="toc-text">反编译</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.2.1.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E5%8A%A0%E8%BD%BD%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">JVM加载类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.1.</span> <span class="toc-text">类的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.1.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">3.1.3.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">3.1.4.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="toc-number">3.2.1.</span> <span class="toc-text">双亲委派</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/ec6e45b4.html" title="SpringBoot自动配置原理"><img src="//img.error0.cn/Springautoconfig-0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot自动配置原理"/></a><div class="content"><a class="title" href="/post/ec6e45b4.html" title="SpringBoot自动配置原理">SpringBoot自动配置原理</a><time datetime="2021-04-08T06:22:23.000Z" title="发表于 2021-04-08 14:22:23">2021-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/a1493e11.html" title="Java8函数式编程"><img src="//img.error0.cn/lambda.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java8函数式编程"/></a><div class="content"><a class="title" href="/post/a1493e11.html" title="Java8函数式编程">Java8函数式编程</a><time datetime="2021-04-03T14:16:19.000Z" title="发表于 2021-04-03 22:16:19">2021-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/sa78128s.html" title="shiro集成redis实现单点登录"><img src="//img.error0.cn/shiroreids.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shiro集成redis实现单点登录"/></a><div class="content"><a class="title" href="/post/sa78128s.html" title="shiro集成redis实现单点登录">shiro集成redis实现单点登录</a><time datetime="2021-02-28T06:35:38.000Z" title="发表于 2021-02-28 14:35:38">2021-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2020.html" title="2020个人年终总结"><img src="https://images.pexels.com/photos/4057655/pexels-photo-4057655.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=750&amp;w=1260" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2020个人年终总结"/></a><div class="content"><a class="title" href="/post/2020.html" title="2020个人年终总结">2020个人年终总结</a><time datetime="2020-12-27T11:52:00.000Z" title="发表于 2020-12-27 19:52:00">2020-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/6bfd7cf7.html" title="Java并发编程-内存模型"><img src="//img.error0.cn//uploads/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8ECPU%E7%BB%84%E7%BB%87.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程-内存模型"/></a><div class="content"><a class="title" href="/post/6bfd7cf7.html" title="Java并发编程-内存模型">Java并发编程-内存模型</a><time datetime="2020-11-15T02:23:56.000Z" title="发表于 2020-11-15 10:23:56">2020-11-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('//img.error0.cn/uploads/3166817309.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 麦兜</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>